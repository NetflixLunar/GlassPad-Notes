<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>GlassPad — Notes</title>

<!-- Prism (syntax highlight) -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism.css">
<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.js"></script>
<!-- Prism language components -->
<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-javascript.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-python.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-cpp.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-java.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-go.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-rust.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-php.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-bash.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-markup.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-css.min.js"></script>
<link rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/command-line/prism-command-line.css">
<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/command-line/prism-command-line.min.js"></script>

<!-- marked for markdown -->
<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

<style>
:root{
  --accent:#007aff;
  --glass: rgba(255,255,255,0.72);
  --border: rgba(255,255,255,0.55);
  --text:#111;
  --shadow: 0 24px 48px rgba(0,0,0,.18);
  --radius:22px;
  --tag-work:#0a84ff; --tag-personal:#34c759; --tag-idea:#ff9500;
  --muted: rgba(0,0,0,.55);
}

/* reset / layout */
*{box-sizing:border-box;margin:0;padding:0}
body{
  font-family:-apple-system,BlinkMacSystemFont,"SF Pro Text","Helvetica Neue",Arial,system-ui;
  background: url('wallhaven-4yk87g_3840x2160.png') center/cover fixed no-repeat;
  min-height:100vh;
  display:flex;
  justify-content:center;
  align-items:flex-start;
  padding:40px;
  color:var(--text);
}

/* glass container */
.container{
  width:100%;
  max-width:980px;
  background:var(--glass);
  backdrop-filter: blur(30px) saturate(180%);
  -webkit-backdrop-filter: blur(30px) saturate(180%);
  border:1px solid var(--border);
  border-radius:var(--radius);
  box-shadow:var(--shadow);
  padding:32px;
}

/* header */
.header{display:flex;justify-content:space-between;align-items:center;margin-bottom:18px}
.title{font-size:26px;font-weight:700;letter-spacing:-0.3px}
.controls{display:flex;gap:8px;align-items:center}

/* forms */
input[type="text"],select,textarea{
  width:100%;
  padding:10px 12px;
  border-radius:12px;
  border:1px solid rgba(0,0,0,.08);
  background:rgba(255,255,255,0.55);
  font-size:14px;
  color:var(--text);
  backdrop-filter: blur(6px);
}
textarea{min-height:130px;resize:none;margin-top:10px}

/* buttons */
.btn{
  border:0;border-radius:12px;padding:10px 14px;font-weight:700;cursor:pointer;font-size:14px;
}
.btn.primary{background:var(--accent);color:white}
.btn.alt{background:rgba(0,0,0,0.06);color:var(--text)}

/* layout */
.layout{display:grid;grid-template-columns:1fr 420px;gap:22px}
@media(max-width:920px){ .layout{grid-template-columns:1fr} }

/* left list */
.left-col{display:flex;flex-direction:column;gap:10px}
.controls-row{display:flex;gap:8px;align-items:center}
.small{font-size:12px;color:var(--muted)}
.kv{font-weight:700;margin-right:6px}

/* notes list */
.list{max-height:60vh;overflow:auto;padding-right:6px}
.note-card{
  background:rgba(255,255,255,0.58);
  border-radius:14px;
  padding:12px;
  margin-bottom:12px;
  border:1px solid rgba(0,0,0,.06);
  transition:transform .12s, box-shadow .12s;
  cursor:pointer;
}
.note-card:hover{transform:translateY(-4px);box-shadow:0 12px 30px rgba(0,0,0,.08)}
.note-head{display:flex;justify-content:space-between;align-items:center}
.note-meta{display:flex;gap:8px;align-items:center}
.note-time{font-size:12px;opacity:.6;margin-bottom:8px}

/* tag & star */
.tag{padding:4px 8px;border-radius:999px;font-size:12px;color:white}
.tag.work{background:var(--tag-work)}
.tag.personal{background:var(--tag-personal)}
.tag.idea{background:var(--tag-idea)}
.star{font-size:16px;cursor:pointer;opacity:.9}

/* preview/right */
.preview{
  background:rgba(255,255,255,0.42);
  border-radius:14px;padding:14px;border:1px solid rgba(0,0,0,.05);
  min-height:220px;
}
.preview h3{margin-top:0;margin-bottom:8px}
.preview pre{
  background:rgba(0,0,0,0.04)!important;padding:12px;border-radius:10px;overflow:auto;position:relative;
}
.code-copy{position:absolute;top:10px;right:10px;background:var(--accent);color:#fff;border:0;padding:6px 8px;border-radius:8px;cursor:pointer;opacity:0;transition:opacity .12s}
.preview pre:hover .code-copy{opacity:1}
@media(max-width:720px){ .code-copy{opacity:1} }

/* search highlight */
mark.search-hit{background:#fffa8b;color:#000;padding:0 2px;border-radius:3px}

/* drag handle */
.drag-handle{cursor:grab;padding:4px 6px;border-radius:6px;background:rgba(0,0,0,.05);font-size:12px}

/* seasonal overlays */
body.season-spring::after,
body.season-summer::after,
body.season-autumn::after,
body.season-winter::after{
  content:"";position:fixed;inset:0;pointer-events:none;mix-blend-mode:screen;opacity:.45;
}
body.season-spring::after{background:linear-gradient(rgba(180,255,210,.05),transparent)}
body.season-summer::after{background:linear-gradient(rgba(255,245,180,.04),transparent)}
body.season-autumn::after{background:linear-gradient(rgba(255,200,160,.06),transparent)}
body.season-winter::after{background:linear-gradient(rgba(255,255,255,.06),transparent)}

/* snackbar */
.snackbar {
  position:fixed; left:50%; transform:translateX(-50%); bottom:28px;
  background: rgba(20,20,20,0.9); color:white; padding:12px 16px; border-radius:10px;
  display:flex; gap:12px; align-items:center; box-shadow:0 8px 24px rgba(0,0,0,.28);
  z-index:9999; opacity:0; pointer-events:none; transition:opacity .18s, transform .18s;
}
.snackbar.show { opacity:1; pointer-events:auto; transform:translateX(-50%) translateY(-6px); }
.snackbar button { background:transparent; color:var(--accent); border:0; font-weight:700; cursor:pointer; }

.preview-split { display:flex; gap:10px; align-items:stretch; height:100%; }
.preview-split > .preview { flex:1; min-width:0; }
.preview-split > .preview.right { width:320px; max-width:45%; min-width:220px; overflow:auto; }

/* volume control */
.volume-wrap { display:flex; align-items:center; gap:8px; padding:6px 10px; background:rgba(0,0,0,.04); border-radius:10px; }

</style>
</head>

<body>
<div class="container" id="app" role="application" aria-label="GlassPad note app">
  <div class="header">
    <div class="title">GlassPad — Notes</div>
    <div class="controls" aria-hidden="false">
      <button id="themeBtn" class="btn alt" title="Cycle seasonal overlay">Season</button>

      <div class="volume-wrap" title="Ambient volume">
        <label for="volume" style="font-size:13px;color:var(--muted);margin-right:6px">Sound</label>
        <input id="volume" type="range" min="0" max="1" step="0.01" value="0.045" style="width:110px">
        <button id="soundBtn" class="btn alt" title="Toggle ambient">Sound: Off</button>
      </div>

      <button id="exportBtn" class="btn alt" title="Export notes">Export</button>
      <label class="btn alt" style="cursor:pointer">
        Import <input id="importFile" type="file" accept="application/json" style="display:none">
      </label>
    </div>
  </div>

  <div class="layout">
    <div class="left-col">
      <input id="search" type="text" placeholder="Search notes (Ctrl/Cmd+K)" aria-label="Search notes">

      <div class="controls-row">
        <select id="langSelect" title="Language" style="width:220px">
          <option value="">Plain Text</option>
          <option value="javascript">JavaScript</option>
          <option value="python">Python</option>
          <option value="cpp">C++</option>
          <option value="c">C</option>
          <option value="java">Java</option>
          <option value="go">Go</option>
          <option value="rust">Rust</option>
          <option value="php">PHP</option>
          <option value="html">HTML</option>
          <option value="css">CSS</option>
          <option value="bash">Bash / Shell</option>
          <option value="bash command-line">Console w/ Prompt</option>
        </select>

        <select id="colorTag" title="Tag">
          <option value="">No Tag</option>
          <option value="work">Work</option>
          <option value="personal">Personal</option>
          <option value="idea">Idea</option>
        </select>

        <label class="small" style="display:flex;align-items:center;gap:6px">
          <input id="pinCheck" type="checkbox"> Pin
        </label>
      </div>

      <textarea id="note" placeholder="Write your note or paste code here..."></textarea>

      <div style="display:flex;gap:10px">
        <button id="saveBtn" class="btn primary" title="Save note">Save (Ctrl/Cmd+Enter)</button>
        <button id="clearDraftBtn" class="btn alt">Clear Draft</button>
        <button id="autoSaveToggle" class="btn alt">AutoSave: On</button>
      </div>

      <div style="display:flex;gap:10px;margin-top:10px">
        <button id="reorderBtn" class="btn alt">Toggle Reorder</button>
        <button id="syncBtn" class="btn alt">Sync (placeholder)</button>
      </div>

      <div class="small" style="margin-top:8px"><span class="kv">Notes:</span> Tap a card to open. Swipe left = delete (undo available), right = pin/unpin. Drag to reorder when enabled.</div>

      <div class="list" id="noteList" aria-live="polite" style="margin-top:12px"></div>
    </div>

    <div class="preview saved-note" id="saved-note" aria-live="polite">
      <p style="opacity:.6">Select a note to preview details and Markdown/code. Live Markdown preview appears while typing.</p>
    </div>
  </div>
</div>

<!-- snackbar for undo -->
<div id="snackbar" class="snackbar" role="status" aria-live="polite" aria-atomic="true" style="display:flex;align-items:center;">
  <span id="snack-msg">Note deleted</span>
  <button id="snack-undo">Undo</button>
</div>

<script>
/* =============================
   Improved GlassPad JS
   - live markdown preview
   - undoable deletes (snackbar)
   - import dedupe or replace
   - swipe updated: right=pin, left=delete-with-undo
   - volume control for ambient sound
   - service worker caches external libs
   ============================== */

document.addEventListener('DOMContentLoaded', () => {
  // --- Model + state ---
  let notes = JSON.parse(localStorage.getItem('notes') || '[]');
  let autosave = true;
  let reorderMode = false;
  let editingId = null;
  let ambientObj = null;
  let seasonIndex = 0;
  const seasons = ['none','season-spring','season-summer','season-autumn','season-winter'];

  // Soft-delete buffer for undo
  let lastDeleted = null; // { note, timeoutId }

  // DOM refs
  const noteEl = document.getElementById('note');
  const langSelect = document.getElementById('langSelect');
  const tagSelect = document.getElementById('colorTag');
  const pinCheck = document.getElementById('pinCheck');
  const noteListEl = document.getElementById('noteList');
  const savedNoteEl = document.getElementById('saved-note');
  const searchEl = document.getElementById('search');
  const snackbar = document.getElementById('snackbar');
  const snackMsg = document.getElementById('snack-msg');
  const snackUndo = document.getElementById('snack-undo');
  const volumeEl = document.getElementById('volume');
  const soundBtn = document.getElementById('soundBtn');

  // Utilities
  function persist(){ localStorage.setItem('notes', JSON.stringify(notes)); }
  function uid(){ return Date.now() + Math.floor(Math.random()*9999); }
  function escapeHtml(s){ return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }
  function escapeRegExp(s){ return s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'); }

  // Restore draft if present
  (function restoreDraft(){
    try {
      const d = JSON.parse(localStorage.getItem('draft') || 'null');
      if(d){
        if(noteEl) noteEl.value = d.text || '';
        if(langSelect) langSelect.value = d.lang || '';
        if(tagSelect) tagSelect.value = d.tag || '';
        if(pinCheck) pinCheck.checked = !!d.pinned;
        renderLivePreview();
      }
    }catch(e){ /* ignore */ }
  })();

  // Autosave draft every 3s
  let autosaveTimer = setInterval(()=>{
    if(!autosave) return;
    const draft = { text: noteEl.value, lang: langSelect.value, tag: tagSelect.value, pinned: pinCheck.checked, timestamp: Date.now() };
    localStorage.setItem('draft', JSON.stringify(draft));
  }, 3000);

  // Ambient generator using WebAudio (white noise lowpass -> gentle ambient)
  function startAmbient(){
    try{
      if(ambientObj) return;
      const AudioCtx = window.AudioContext || window.webkitAudioContext;
      const ctx = new AudioCtx();
      const bufferSize = 2 * ctx.sampleRate;
      const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
      const data = buffer.getChannelData(0);
      for(let i=0;i<bufferSize;i++){
        data[i] = (Math.random() * 2 - 1) * 0.35;
      }
      const source = ctx.createBufferSource();
      source.buffer = buffer;
      source.loop = true;
      const filter = ctx.createBiquadFilter();
      filter.type = 'lowpass';
      filter.frequency.value = 800;
      const gain = ctx.createGain();
      gain.gain.value = parseFloat(volumeEl.value) || 0.045;
      source.connect(filter); filter.connect(gain); gain.connect(ctx.destination);
      source.start(0);
      ambientObj = { ctx, source, gain };
      soundBtn.textContent = 'Sound: On';
    }catch(e){
      console.warn('Ambient failed', e);
      alert('Ambient audio not supported in this browser.');
    }
  }
  function stopAmbient(){
    if(!ambientObj) return;
    try{
      ambientObj.source.stop();
      if(ambientObj.ctx && ambientObj.ctx.close) ambientObj.ctx.close();
    }catch(e){/* ignore */}
    ambientObj = null;
    soundBtn.textContent = 'Sound: Off';
  }

  volumeEl.addEventListener('input', () => {
    if(ambientObj && ambientObj.gain) ambientObj.gain.gain.value = parseFloat(volumeEl.value);
  });

  // Highlight helper for search snippet
  function highlightText(text, query){
    if(!query) return escapeHtml(text);
    const q = query.trim();
    if(!q) return escapeHtml(text);
    // highlight each match of any keyword
    const parts = q.split(/\s+/).filter(Boolean).map(escapeRegExp);
    if(parts.length === 0) return escapeHtml(text);
    const re = new RegExp('(' + parts.join('|') + ')', 'ig');
    return escapeHtml(text).replace(re, (m) => `<mark class="search-hit">${m}</mark>`);
  }

  // Build Prism classes for pre/code
  function buildLangClasses(val){
    if(!val) return {pre:'', code:''};
    const parts = val.trim().split(/\s+/);
    const pre = parts.map(p => p === 'command-line' ? 'command-line' : 'language-' + p).join(' ');
    const code = parts.map(p => p === 'command-line' ? '' : 'language-' + p).filter(Boolean).join(' ');
    return { pre, code };
  }

  // Search predicate: multi-keyword across text + tag
  function matchesQuery(note, query){
    if(!query) return true;
    const terms = query.toLowerCase().split(/\s+/).filter(Boolean);
    if(terms.length === 0) return true;
    const hay = (note.text + ' ' + (note.tag || '')).toLowerCase();
    return terms.every(t => hay.indexOf(t) !== -1);
  }

  // Render the notes list
  function renderNotes(){
    noteListEl.innerHTML = '';
    if(!notes.length){ noteListEl.innerHTML = '<p style="opacity:.6">No notes yet.</p>'; return; }

    const q = (searchEl.value || '').trim();

    // sort pinned first, then by order if present, else createdAt desc
    const sorted = notes.slice().sort((a,b) => {
      if((a.pinned?1:0) !== (b.pinned?1:0)) return (b.pinned?1:0) - (a.pinned?1:0);
      if(typeof a.order === 'number' && typeof b.order === 'number') return a.order - b.order;
      return new Date(b.createdAt) - new Date(a.createdAt);
    });

    for(const n of sorted){
      if(!matchesQuery(n, q)) continue;

      // build preview (limit length)
      let previewRaw = n.text.length > 220 ? n.text.slice(0,220) + '…' : n.text;
      let previewHtml = q ? highlightText(previewRaw, q) : escapeHtml(previewRaw);

      const card = document.createElement('div');
      card.className = 'note-card';
      card.dataset.id = n.id;
      card.setAttribute('draggable', reorderMode ? 'true' : 'false');

      const tagHtml = n.tag ? `<span class="tag ${escapeHtml(n.tag)}">${escapeHtml(n.tag)}</span>` : '';

      card.innerHTML = `
        <div class="note-head">
          <div style="display:flex;gap:8px;align-items:center">
            <div class="drag-handle" style="display:${reorderMode ? 'inline-flex' : 'none'}">☰</div>
            <div>
              <div class="note-time">${new Date(n.createdAt).toLocaleString()}</div>
              <div style="font-size:14px">${previewHtml}</div>
            </div>
          </div>
          <div class="note-meta">
            ${tagHtml}
            <div class="star" data-id="${n.id}" title="Pin/unpin">${n.pinned ? '⭐' : '☆'}</div>
          </div>
        </div>`;

      // click to open (avoid click on star)
      card.addEventListener('click', (ev) => {
        if(ev.target.classList.contains('star') || ev.target.closest('.star')) return;
        if(ev.target.classList.contains('drag-handle')) return;
        showNoteDetails(Number(card.dataset.id));
      });

      // star toggle
      const star = card.querySelector('.star');
      star && star.addEventListener('click', (e) => {
        e.stopPropagation();
        togglePin(Number(star.dataset.id));
      });

      addSwipeHandlers(card); // touch
      addCardDragHandlers(card);

      noteListEl.appendChild(card);
    }
  }

  // Live markdown preview while typing
  function renderLivePreview(){
    const text = noteEl.value || '';
    const lang = langSelect.value || '';

    // If a code language is selected, show code block (Prism) on RHS
    if(lang){
      const classes = buildLangClasses(lang);
      savedNoteEl.innerHTML = `<div class="preview-split"><div class="preview"><h3>Editor</h3><pre style="white-space:pre-wrap;min-height:160px">${escapeHtml(text)}</pre></div><div class="preview right"><h3>Live Code Preview</h3><pre class="${classes.pre}"><code class="${classes.code}">${escapeHtml(text)}</code></pre></div></div>`;
      Prism.highlightAllUnder(savedNoteEl);
      // add copy button to right pre
      const pre = savedNoteEl.querySelector('.preview.right pre');
      if(pre){
        const btn = document.createElement('button'); btn.className='code-copy'; btn.textContent='Copy';
        btn.addEventListener('click', ()=> navigator.clipboard.writeText(text).then(()=>{ btn.textContent='Copied!'; setTimeout(()=>btn.textContent='Copy',1000); }));
        pre.style.position='relative'; pre.appendChild(btn);
      }
    } else {
      savedNoteEl.innerHTML = `<div class="preview-split"><div class="preview"><h3>Editor</h3><pre style="white-space:pre-wrap;min-height:160px">${escapeHtml(text)}</pre></div><div class="preview right"><h3>Live Markdown Preview</h3><div>${marked.parse(text || '')}</div></div></div>`;
    }
  }

  // Show note details with Prism highlight and markdown preview
  function showNoteDetails(id){
    const note = notes.find(n => n.id === Number(id));
    if(!note) return;
    const classes = buildLangClasses(note.lang || '');
    let mainHtml = '';
    if(note.lang){
      mainHtml = `<pre class="${classes.pre}"><code class="${classes.code}">${escapeHtml(note.text)}</code></pre>`;
    } else {
      mainHtml = `<div>${marked.parse(note.text)}</div>`;
    }

    const tagHtml = note.tag ? `<div style="margin-top:8px"><span class="tag ${escapeHtml(note.tag)}">${escapeHtml(note.tag)}</span></div>` : '';

    savedNoteEl.innerHTML = `
      <h3>Note Details</h3>
      <div id="note-main">${mainHtml}</div>
      ${tagHtml}
      <p style="margin-top:12px"><strong>Created:</strong> ${new Date(note.createdAt).toLocaleString()}</p>
      <div style="display:flex;gap:8px;margin-top:12px">
        <button id="detail-edit" class="btn primary">Edit</button>
        <button id="detail-delete" class="btn alt">Delete</button>
      </div>

      <div style="margin-top:12px">
        <div contenteditable="true" id="console-scratch" class="small" style="background:rgba(0,0,0,0.03);padding:10px;border-radius:8px;min-height:40px">Console / scratchpad — editable</div>
      </div>
    `;

    // add copy button to pre if exists
    const preEl = savedNoteEl.querySelector('pre');
    if(preEl){
      const btn = document.createElement('button');
      btn.className = 'code-copy';
      btn.textContent = 'Copy';
      btn.addEventListener('click', ()=> {
        const codeEl = preEl.querySelector('code');
        if(!codeEl) return;
        navigator.clipboard.writeText(codeEl.innerText).then(()=>{
          const old = btn.textContent;
          btn.textContent = 'Copied!';
          setTimeout(()=>btn.textContent = old,1200);
        }).catch(()=>alert('Copy failed'));
      });
      preEl.style.position = 'relative';
      preEl.appendChild(btn);
    }

    // detail button handlers
    document.getElementById('detail-edit').addEventListener('click', ()=> {
      editNote(note.id);
    });
    document.getElementById('detail-delete').addEventListener('click', ()=> {
      scheduleDelete(note.id);
    });

    Prism.highlightAllUnder(savedNoteEl);
  }

  // Save note (create or update)
  function saveNote(){
    const text = noteEl.value.trim();
    if(!text){ alert('Write something before saving.'); return; }
    const lang = langSelect.value;
    const tag = tagSelect.value;
    const pinned = pinCheck.checked;
    if(editingId){
      // update existing
      const idx = notes.findIndex(n => n.id === editingId);
      if(idx !== -1){
        notes[idx].text = text;
        notes[idx].lang = lang;
        notes[idx].tag = tag;
        notes[idx].pinned = pinned;
      } else {
        notes.push({ id: editingId, text, lang, tag, pinned, createdAt: new Date().toISOString() });
      }
      editingId = null;
    } else {
      const newNote = { id: uid(), text, lang, tag, pinned, createdAt: new Date().toISOString() };
      notes.push(newNote);
    }
    persist();
    renderNotes();
    clearDraft(false);
    renderLivePreview();
  }

  // Soft-delete with undo
  function scheduleDelete(id){
    const idx = notes.findIndex(n => n.id === id);
    if(idx === -1) return;
    const note = notes[idx];
    // Remove immediately from the UI list (optimistic)
    notes.splice(idx,1);
    persist();
    renderNotes();
    // Save lastDeleted and give user ~6 seconds to undo
    if(lastDeleted && lastDeleted.timeoutId) { clearTimeout(lastDeleted.timeoutId); lastDeleted = null; }
    const timeoutId = setTimeout(()=> {
      lastDeleted = null;
      hideSnackbar();
      // permanently gone (we already removed from notes and persisted)
    }, 6000);
    lastDeleted = { note, timeoutId };
    showSnackbar('Note deleted', true);
  }

  function undoDelete(){
    if(!lastDeleted) return;
    clearTimeout(lastDeleted.timeoutId);
    notes.push(lastDeleted.note);
    persist();
    lastDeleted = null;
    renderNotes();
    hideSnackbar();
  }

  // Delete immediately (used rarely when confirming)
  function deleteNoteImmediate(id){
    notes = notes.filter(n => n.id !== id);
    persist();
    renderNotes();
    savedNoteEl.innerHTML = '<p style="opacity:.6">Select a note to preview details and Markdown/code.</p>';
  }

  // Edit note (populate editor)
  function editNote(id){
    const idx = notes.findIndex(n => n.id === id);
    if(idx === -1) return;
    const n = notes[idx];
    noteEl.value = n.text;
    langSelect.value = n.lang || '';
    tagSelect.value = n.tag || '';
    pinCheck.checked = !!n.pinned;
    editingId = n.id;
    // remove temporary from array so save replaces it
    notes.splice(idx,1);
    persist();
    renderNotes();
    noteEl.focus();
    renderLivePreview();
  }

  // Toggle pin
  function togglePin(id){
    const n = notes.find(x => x.id === Number(id));
    if(!n) return;
    n.pinned = !n.pinned;
    persist(); renderNotes();
  }

  // Clear draft
  function clearDraft(showAlert=true){
    noteEl.value = '';
    langSelect.value = '';
    tagSelect.value = '';
    pinCheck.checked = false;
    editingId = null;
    renderLivePreview();
    if(showAlert) alert('Draft cleared.');
  }

  // Export/Import (improved import)
  function exportNotes(){
    const data = JSON.stringify(notes, null, 2);
    const blob = new Blob([data], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a'); a.href = url; a.download = 'glasspad-notes.json'; a.click();
    URL.revokeObjectURL(url);
  }

  function importNotes(file){
    const reader = new FileReader();
    reader.onload = () => {
      try{
        const imported = JSON.parse(reader.result);
        if(!Array.isArray(imported)) throw new Error('Invalid file format (expected array)');
        // detect duplicates by text + createdAt
        const dupes = [];
        const additions = [];
        for(const it of imported){
          const exists = notes.some(n => n.text === it.text && n.createdAt === it.createdAt);
          if(exists) dupes.push(it);
          else additions.push(it);
        }
        if(dupes.length > 0){
          // ask user: skip duplicates (merge), or replace all
          const choice = confirm(`${dupes.length} duplicate(s) detected. OK to merge (skip duplicates). Cancel to replace all notes with imported file.`);
          if(choice){
            // Merge: append additions, assign new ids
            additions.forEach(it => {
              it.id = uid();
              it.createdAt = it.createdAt || new Date().toISOString();
              notes.push(it);
            });
            persist(); renderNotes(); alert('Import merged (skipped duplicates).');
          } else {
            // Replace all
            const cleaned = imported.map(it => {
              return { id: uid(), text: it.text || '', lang: it.lang || '', tag: it.tag || '', pinned: !!it.pinned, createdAt: it.createdAt || new Date().toISOString() };
            });
            notes = cleaned;
            persist(); renderNotes(); alert('Imported notes replaced current notes.');
          }
        } else {
          // no duplicates: append
          imported.forEach(it => {
            it.id = uid();
            it.createdAt = it.createdAt || new Date().toISOString();
            notes.push(it);
          });
          persist(); renderNotes(); alert('Imported notes added.');
        }
      }catch(e){
        alert('Import failed: ' + e.message);
      }
    };
    reader.readAsText(file);
  }

  // Drag & Drop helpers (list-level listeners attached once)
  function getDragAfterElement(container, y){
    const draggableElements = [...container.querySelectorAll('.note-card:not(.dragging)')];
    return draggableElements.reduce((closest, child) => {
      const box = child.getBoundingClientRect();
      const offset = y - box.top - box.height / 2;
      if(offset < 0 && offset > closest.offset) return { offset: offset, element: child };
      else return closest;
    }, { offset: Number.NEGATIVE_INFINITY }).element;
  }

  // Add drag handlers for an individual card
  function addCardDragHandlers(card){
    card.addEventListener('dragstart', (e) => {
      if(!reorderMode) { e.preventDefault(); return; }
      card.classList.add('dragging');
      e.dataTransfer.effectAllowed = 'move';
      try { e.dataTransfer.setData('text/plain', card.dataset.id); } catch(e){}
    });
    card.addEventListener('dragend', () => card.classList.remove('dragging'));
  }

  // Setup list dragover & drop once
  (function setupListDrag(){
    noteListEl.addEventListener('dragover', (e) => {
      if(!reorderMode) return;
      e.preventDefault();
      const after = getDragAfterElement(noteListEl, e.clientY);
      const dragging = noteListEl.querySelector('.dragging');
      if(!dragging) return;
      if(after == null) noteListEl.appendChild(dragging);
      else noteListEl.insertBefore(dragging, after);
    });
    noteListEl.addEventListener('drop', (e) => {
      if(!reorderMode) return;
      e.preventDefault();
      // save order
      const cards = Array.from(noteListEl.children);
      cards.forEach((c, idx) => {
        const id = Number(c.dataset.id);
        const note = notes.find(n => n.id === id);
        if(note) note.order = idx;
      });
      persist();
      renderNotes();
    });
  })();

  // Swipe touch handlers for mobile: right = pin/unpin, left = delete-with-undo
  function addSwipeHandlers(el){
    let startX = 0, startY = 0, active = false;
    el.addEventListener('touchstart', (e) => {
      const t = e.touches[0];
      startX = t.clientX; startY = t.clientY; active = true;
      el.style.transition = 'none';
    }, {passive:true});
    el.addEventListener('touchmove', (e) => {
      if(!active) return;
      const t = e.touches[0];
      const dx = t.clientX - startX;
      const dy = t.clientY - startY;
      if(Math.abs(dx) > Math.abs(dy)){
        e.preventDefault();
        el.style.transform = `translateX(${dx}px)`;
      }
    }, {passive:false});
    el.addEventListener('touchend', (e) => {
      if(!active) return;
      active = false; el.style.transition = 'transform .2s';
      const transform = getComputedStyle(el).transform;
      let tx = 0;
      if(transform && transform !== 'none'){
        const vals = transform.match(/matrix.*\((.+)\)/);
        if(vals && vals[1]){
          const arr = vals[1].split(', ');
          tx = parseFloat(arr[4]);
        }
      }
      el.style.transform = 'translateX(0)';
      const id = Number(el.dataset.id);
      if(tx < -100){
        // delete (undoable)
        scheduleDelete(id);
      } else if(tx > 100){
        // pin/unpin
        togglePin(id);
      }
    }, {passive:true});
  }

  // Snackbar helpers
  function showSnackbar(msg, showUndo){
    snackMsg.textContent = msg;
    snackUndo.style.display = showUndo ? 'inline-block' : 'none';
    snackbar.classList.add('show');
  }
  function hideSnackbar(){
    snackbar.classList.remove('show');
  }
  snackUndo.addEventListener('click', () => undoDelete());

  // Keyboard shortcuts
  document.addEventListener('keydown', (e) => {
    const mod = navigator.platform.toLowerCase().includes('mac') ? e.metaKey : e.ctrlKey;
    if(mod && (e.key === 'Enter' || e.key === 'Enter')){ e.preventDefault(); saveNote(); }
    if(mod && e.key.toLowerCase() === 'k'){ e.preventDefault(); searchEl.focus(); }
    if(e.key === 'Escape'){ // cancel edit/drafts quickly
      editingId = null;
    }
  });

  // --- Event wiring (DOM elements) ---
  // Save
  const saveBtn = document.getElementById('saveBtn');
  saveBtn && saveBtn.addEventListener('click', saveNote);

  // Clear draft
  const clearDraftBtn = document.getElementById('clearDraftBtn');
  clearDraftBtn && clearDraftBtn.addEventListener('click', ()=> clearDraft(true));

  // Live preview on input and language change
  noteEl.addEventListener('input', renderLivePreview);
  langSelect.addEventListener('change', renderLivePreview);

  // Search
  searchEl && searchEl.addEventListener('input', () => renderNotes());

  // Export
  document.getElementById('exportBtn').addEventListener('click', exportNotes);

  // Import
  const importFileEl = document.getElementById('importFile');
  importFileEl && importFileEl.addEventListener('change', (ev) => {
    const f = ev.target.files && ev.target.files[0];
    if(f) importNotes(f);
    importFileEl.value = '';
  });

  // Reorder toggle
  const reorderBtn = document.getElementById('reorderBtn');
  reorderBtn && reorderBtn.addEventListener('click', () => {
    reorderMode = !reorderMode;
    reorderBtn.textContent = reorderMode ? 'Reordering: On' : 'Toggle Reorder';
    renderNotes();
  });

  // Sync placeholder
  const syncBtn = document.getElementById('syncBtn');
  syncBtn && syncBtn.addEventListener('click', () => {
    alert('Multi-device sync requires a backend (Firebase/Supabase). I can help wire it if you want.');
    console.info('To enable sync: choose backend, add API keys, implement push/pull functions.');
  });

  // Season button
  const themeBtn = document.getElementById('themeBtn');
  themeBtn && themeBtn.addEventListener('click', () => {
    seasonIndex = (seasonIndex + 1) % seasons.length;
    document.body.className = seasons[seasonIndex] === 'none' ? '' : seasons[seasonIndex];
  });

  // Sound toggle
  soundBtn && soundBtn.addEventListener('click', () => {
    if(ambientObj){ stopAmbient(); } else { startAmbient(); }
  });

  // Autosave toggle
  const autoBtn = document.getElementById('autoSaveToggle');
  autoBtn && autoBtn.addEventListener('click', () => {
    autosave = !autosave;
    autoBtn.textContent = `AutoSave: ${autosave ? 'On' : 'Off'}`;
    if(autosave && !autosaveTimer) {
      autosaveTimer = setInterval(()=> {
        if(!autosave) return;
        const draft = { text: noteEl.value, lang: langSelect.value, tag: tagSelect.value, pinned: pinCheck.checked, timestamp: Date.now() };
        localStorage.setItem('draft', JSON.stringify(draft));
      }, 3000);
    }
  });

  // Dynamic blur on scroll
  noteListEl.addEventListener('scroll', (e) => {
    const sc = e.target.scrollTop || 0;
    const blur = Math.min(48, 22 + sc / 30);
    document.querySelector('.container').style.backdropFilter = `blur(${blur}px) saturate(180%)`;
  });

  // Render initially
  renderNotes();
  renderLivePreview();

  // PWA manifest + service worker improved caching (best-effort)
  (function registerPWA(){
    try{
      const manifest = {
        name: "GlassPad",
        short_name: "GlassPad",
        start_url: ".",
        display: "standalone",
        background_color: "#ffffff",
        icons: [{ src: "wallhaven-4yk87g_3840x2160.png", sizes: "512x512", type: "image/png" }]
      };
      const blob = new Blob([JSON.stringify(manifest)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('link'); link.rel = 'manifest'; link.href = url;
      document.head.appendChild(link);

      if('serviceWorker' in navigator){
        const swCode = `
          const CACHE = 'glasspad-v2';
          const urlsToCache = ['./', 'https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism.css', 'https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.js', 'https://cdn.jsdelivr.net/npm/marked/marked.min.js', 'wallhaven-4yk87g_3840x2160.png'];
          self.addEventListener('install', e => {
            self.skipWaiting();
            e.waitUntil(caches.open(CACHE).then(cache => cache.addAll(urlsToCache)).catch(()=>{}));
          });
          self.addEventListener('activate', e => { self.clients.claim(); });
          self.addEventListener('fetch', e => {
            e.respondWith(caches.match(e.request).then(r => r || fetch(e.request).then(res => {
              // optionally cache fetched assets
              return res;
            })));
          });
        `;
        const swBlob = new Blob([swCode], { type: 'application/javascript' });
        const swUrl = URL.createObjectURL(swBlob);
        navigator.serviceWorker.register(swUrl).then(()=> console.info('SW registered (if supported)')).catch(()=> console.info('SW not registered'));
      }
    }catch(err){ console.warn('PWA skipped', err); }
  })();

  // Expose a couple helpers for debugging
  window.showNoteDetails = showNoteDetails;
  window.editNote = editNote;
  window.deleteNoteImmediate = deleteNoteImmediate;
  window.togglePin = togglePin;

}); // DOMContentLoaded
</script>
</body>
</html>
